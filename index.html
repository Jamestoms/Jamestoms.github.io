<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>jamestoms的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="jamestoms的博客">
<meta property="og:url" content="https://jamestoms.github.io/index.html">
<meta property="og:site_name" content="jamestoms的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jamestoms的博客">
  
    <link rel="alternate" href="/atom.xml" title="jamestoms的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/cat.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" style="background-image: url(/images/bg.webp)" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title>首页</a>
      
        <a class="nav-item" href="/archives" title>归档</a>
      
        <a class="nav-item" href="https://github.com/Jamestoms" title>github</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-javascript" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/19/javascript/">Javascript</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/05/19/javascript/" class="article-date">
  <time datetime="2019-05-18T16:00:00.000Z" itemprop="datePublished">2019-05-19</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>5种简单数据类型</li>
</ol>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
<ol start="2">
<li>1种复杂数据类型</li>
</ol>
<ul>
<li>Object</li>
</ul>
<p>所有值最终都将是上述6种数据类型之一<br>注：es6新增了一种新的原始数据类型Symbol，它是JavaScript语言的第七种数据类型，前六种是undefined、null、布尔值(Boolean)、字符串(String)、数值(Number)、对象(Object)。</p>
<h1 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h1><pre><code>typeof(obj)</code></pre><p>typeof是一个操作符而不是函数,所以圆括号可以使用，但不是必须的。<br>可能返回的值有：</p>
<ul>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>object</li>
<li>function<br>note: 调用typeof null会返回‘object’,因为特殊值null会被认为是一个空的对象引用<br>NaN是一个特殊的数值类型</li>
</ul>
<ul>
<li>Object 类型的每个实例都具有下列属性和方法：</li>
</ul>
<ul>
<li>constructor: 保存着用于创建当前对象的函数</li>
<li>hasOwnProperty(propertyName): 用于检测给定的属性在当前对象实例中(不是在实例的原型中)是否存在。propertyName必须是字符串</li>
<li>isPrototypeOf(object): 用于检测传入的对象是否是传入对象的原型</li>
<li>propertyIsEnumerable(propertyName): 用于检测给定的属性是否能够使用for-in语句来枚举。参数必须是字符串。</li>
<li>toLocaleString(): 返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString(): 返回对象的字符串表示</li>
<li>valueOf(): 返回对象的字符串、数值或布尔值表示</li>
</ul>
<h1 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h1>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-webpack" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/16/webpack/">webpack基本配置</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/05/16/webpack/" class="article-date">
  <time datetime="2019-05-15T16:00:00.000Z" itemprop="datePublished">2019-05-16</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>打包方式有命令行和配置文件方式，主要用配置文件方式</p>
<h1 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h1><ul>
<li>externals</li>
<li>target</li>
<li>cache</li>
<li>loader</li>
<li>devServer</li>
<li>plugins</li>
<li>context</li>
<li>entry</li>
<li>output</li>
<li>module</li>
<li>resolve</li>
<li>resolveLoader</li>
</ul>
<p>[webpack中文网配置文件说明]<a href="https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9</a></p>
<p>下面介绍几个常用选项含义和用法</p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context选项用来配置基础路径（必须为绝对路径），默认为process.cwd()，即运行webpack命令的目录。</p>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry选项用来配置要打包的入口文件，值可以是字符串、数组、对象。该选项指定的路径会相对context选项指定的路径进行查找。</p>
<ol>
<li>字符串<br>直接指定路径，该路径相对于context选项。<br> entry: “./entry”</li>
<li>数组<br>路径数组，Webpack会按序打包，但是只导出最后一个文件。<br> entry: [“./entry1”, “./entry2”]</li>
<li>对象<br>当entry值为对象时，键名为块名，可以随意指定，键值可以为字符串或数组类型。该块名可以在output选项中使用，代码示例如下：<br> {<br>   entry: {<pre><code>page1: &quot;./page1&quot;,
page2: [&quot;./entry1&quot;, &quot;./entry2&quot;]</code></pre>   },<br>   output: {<pre><code>// 打包后输出文件名，name为entry中对应的键名</code></pre>   filename: “[name].bundle.js”<br>   }<br> }<br>以上选项配置后，运行命令在项目根目录下会生成page1.bundle.js和page2.bundle.js文件。</li>
</ol>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>utput选项可用来配置输出信息：<br>output.filename<br>配置打包后的文件名，注意值不是绝对路径。我们应该通过output.path来指定输出路径，filename会相对output.path来输出，代码示例如下：<br>// 单入口示例<br>    {<br>      entry: ‘./src/app.js’,<br>      output: {<br>        filename: ‘bundle.js’,<br>        path: __dirname + ‘/build’<br>      }<br>    }<br>// 写入磁盘路径为./build/bundle.js<br>如果项目有多个入口，对于每个入口打包后的文件名我们需要保证其唯一性。Webpack提供了以下模式来动态生成输出文件名：<br>[name]，入口文件块名。<br>[hash]，每个入口打包后的hash值。<br>[chunkhash]，在使用代码分割时，异步加载的文件的hash值。<br>// 多入口示例<br>    {<br>      entry: {<br>        app: ‘./src/app.js’,<br>        search: ‘./src/search.js’<br>      },<br>      output: {<br>        filename: ‘[name].js’,<br>        // filename: ‘[hash].js’,<br>        // filename: ‘[chunkhash].js’,<br>        path: __dirname + ‘/build’<br>      }<br>    }<br>// 写入磁盘路径为./build/app.js、./build/search.js<br>output.path——打包后的文件的根目录（绝对路径）。</p>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>module选项用来进行模块加载相关配置。<br>module.loaders——加载器数组，当依赖文件匹配指定的test模式时，Webpack会自动调用数组中的相应加载器去处理该文件，然后返回JS格式的文件。<br>加载器是一个对象，该对象拥有以下属性：<br>test —— 正则表达式，Webpack用其去匹配相应的文件，通常用来匹配文件后缀。<br>exclude —— 不应该被loader处理的文件。<br>include —— 一个路径数组，这些路径将会被loader处理。<br>loader —— test匹配到的文件对应的加载器，值是一个加载器名字字符串，多个加载器之间用“!”分隔。<br>代码示例如下：<br>    module: {<br>      loaders: [<br>        {<br>          // 匹配jsx后缀的文件<br>          test: /.jsx$/,<br>          // include中的目录会被loader解析<br>          include: [<br>            path.resolve(<strong>dirname, “app/src”),<br>            path.resolve(</strong>dirname, “app/test”)<br>          ],<br>          // babel loader，该loader可以用来解析ES 6语法<br>          loader: “babel-loader” // 或者 “babel”， Webpack 将会自动添加 ‘-loader’<br>        }<br>      ]<br>    }</p>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>resolve选项用来配置依赖文件的匹配，如依赖文件别名配置、模块的查找目录、默认查找的文件后缀等。</p>
<ol>
<li>resolve.alias<br>该选项用来配置依赖文件的别名，值是一个对象，该对象的键是别名，值是实际路径。</li>
<li>resolve.root<br>该选项用来指定模块的查找根路径，必须为绝对路径，值可以是路径字符串或者路径数组。若是路径数组，Webpack会依次在这些路径中查找，如果找到则终止；否则会继续在下一个路径中查找。代码示例如下：<br>// webpack.config.js<br> var path = require(‘path’);<br> // …<br> resolve: {<br>   root: [<pre><code>path.resolve(&apos;./app/modules&apos;),
path.resolve(&apos;./vendor/modules&apos;)</code></pre>   ]<br> }</li>
<li>resolve.modulesDirectories<br>该选项用来指定模块目录，值是一个路径数组，默认值为[“web_modules”, “node_modules”]。</li>
</ol>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p>evServer选项可用来配置webpack-dev-server的行为。以下代码用来指定服务的根路径：<br>    {<br>      devServer: {<br>        contentBase: “./build”,<br>    }<br>    }</p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>我们需要通过npm安装相关的插件，这里以WebpackBrowserPlugin为例，该插件用来在Webpack或webpack-dev-server运行完成后启动浏览器。<br>    module.exports = {<br>      …<br>      …<br>      plugins: [<br>        new WebpackBrowserPlugin()<br>      ],<br>      …<br>    }<br>插件的具体使用方式可以到插件的官方网站查询，一般会有说明如何使用。<br>下面介绍几款Webpack内置的常用插件的使用</p>
<ol>
<li>DefinePlugin<br>DefinePlugin插件用来替换指定变量，代码示例如下：<br>// webpack.config.js<br> var webpack = require(‘webpack’);<br> module.exports = {<br>   …<br>   …<br>   plugins: [<pre><code>new webpack.DefinePlugin({
  VERSION: JSON.stringify(&quot;5fa3b9&quot;),
  BROWSER_SUPPORTS_HTML5: true,
  TWO: &quot;1+1&quot;
})</code></pre>   ],<br>   …<br> }<br>// 待编译的文件<br> console.log(“Running App version “ + VERSION)// 编译后：console.log(“Running App version “ + “5fa3b9”)<br>if(!BROWSER_SUPPORTS_HTML5) require(“html5shiv”)// 编译后：if(!true) require(“html5shiv”)<br>var two = TWO// 编译后：var two = 1+1</li>
<li>ProvidePlugin<br>ProvidePlugin可以自动加载当前模块依赖的其他模块并以指定别名注入到当前模块中。假如当前模块依赖jquery模块，同时我们想在模块中直接用“$”引用jQuery对象，但是不想手动require jquery模块。代码示例如下：<br>// 当前模块<br>$(“#item”)<br>此时我们只需要在Webpack配置文件中配置ProvidePlugin插件将jquery模块导出为 $ 变量即可。代码示例如下：<br>// webpack.config.js<br> var webpack = require(‘webpack’);<br> module.exports = {<br>   …<br>   …<br>   plugins: [<pre><code>// 自动引入 jquery 模块并导出为 $ 变量，使各个模块可以直接通过“$”来引用 jQuery 对象
new webpack.ProvidePlugin({
    $: &quot;jquery&quot;
})</code></pre>   ],<br>   …<br> }</li>
</ol>
<p>需另外安装的插件</p>
<ol start="3">
<li>HtmlWebpackPlugin<br>使用index.html模板文件生成index.html文件且自动引入打包后的js,css文件插件</li>
</ol>
<p>此外还有代码压缩，打包清理等众多插件可供使用</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Vue-component-interaction" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/Vue-component-interaction/">Vue组件交互的方式</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/05/07/Vue-component-interaction/" class="article-date">
  <time datetime="2019-05-06T16:00:00.000Z" itemprop="datePublished">2019-05-07</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <ol>
<li>props和$emit<br>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。</li>
</ol>
<ol start="2">
<li>特性绑定$attrs和$listeners<br>如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？ 如果继续用上面的方法，会变得非常复杂，不利于维护；Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。</li>
</ol>
<ol start="3">
<li>中央事件总线 Events Bus<br>新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</li>
</ol>
<ol start="4">
<li><p>依赖注入：provide和inject<br>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。<br>不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用</p>
</li>
<li><p>v-model<br>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p>
</li>
</ol>
<ol start="6">
<li><p>子组件引用：ref和$refs</p>
</li>
<li><p>父链和子索引：$parent和$children</p>
</li>
<li><p>vue1中boradcast和dispatch<br>vue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。</p>
</li>
<li><p>vuex</p>
</li>
</ol>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-python" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/python/">python</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/04/09/python/" class="article-date">
  <time datetime="2019-04-08T16:00:00.000Z" itemprop="datePublished">2019-04-09</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值(None)</li>
<li>list(js中的数组)</li>
<li>tuple(tuple和list非常类似，但是tuple一旦初始化就不能修改)</li>
<li>dict(js中的对象)</li>
<li>set(set和dict类似，也是一组key的集合，但不存储value)</li>
</ul>
<p>s = set([1,2,3])  //{1,2,3}</p>
<ul>
<li><p>条件判断(缩进规则)</p>
<p>  age = 3<br>  if age &gt;= 18:</p>
<pre><code>print(&apos;your age is&apos;, age)
print(&apos;adult&apos;)</code></pre><p>  else:</p>
<pre><code>print(&apos;your age is&apos;, age)
print(&apos;teenager&apos;)</code></pre></li>
<li><p>循环</p>
<ul>
<li><p>for x in …</p>
<p>sum = 0<br>for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</p>
<pre><code>sum = sum + x</code></pre><p>print(sum)</p>
</li>
<li><p>while</p>
<p>sum = 0<br>n = 99<br>while n &gt; 0:</p>
<pre><code>sum = sum + n
n = n - 2</code></pre><p>print(sum)</p>
</li>
<li><p>break,continue</p>
<p>n = 1<br>while n &lt;= 100:</p>
<pre><code>if n &gt; 10: # 当n = 11时，条件满足，执行break语句
    break # break语句会结束当前循环
print(n)
n = n + 1</code></pre><p>print(‘END’)</p>
</li>
</ul>
</li>
</ul>
<pre><code>n = 0
while n &lt; 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
    print(n)</code></pre><ul>
<li><p>函数</p>
<ul>
<li>数据类型转换<ul>
<li>int()</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
</ul>
</li>
<li><p>函数定义</p>
<ul>
<li><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p>
<p>def my_abs(x):</p>
<pre><code>if x &gt;= 0:
    return x
else:
    return -x</code></pre></li>
<li><p>空函数</p>
<p>def nop():</p>
<pre><code>pass</code></pre></li>
<li><p>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。pass还可以用在其他语句里，比如：</p>
<p>if age &gt;= 18:</p>
<pre><code>pass     #缺少了pass，代码运行就会有语法错误。</code></pre></li>
<li><p>参数检查(参数个数不对不会抛错)</p>
</li>
<li><p>返回多个值(return n1,n2,n3)(看似多个值，其实返回的是一个tuple，无显式返回值时返回值为None)</p>
</li>
<li><p>可变参数(在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去)</p>
</li>
<li><p>关键字参数<br>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p>
</li>
</ul>
</li>
</ul>
<h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><pre><code>def person(name, age, **kw):
    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</code></pre><p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<pre><code>--&gt; person(&apos;Michael&apos;, 30)
name: Michael age: 30 other: {}</code></pre><p>也可以传入任意个数的关键字参数：</p>
<pre><code>--&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)
name: Bob age: 35 other: {&apos;city&apos;: &apos;Beijing&apos;}
--&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)
name: Adam age: 45 other: {&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><p>关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>
<pre><code>--&gt; extra = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}
--&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])
name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><p>当然，上面复杂的调用可以用简化的写法：</p>
<pre><code>--&gt; extra = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}
--&gt; person(&apos;Jack&apos;, 24, **extra)
name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><p><strong>extra表示把extra这个dict的所有key-value用关键字参数传入到函数的</strong>kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p>
<h1 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h1><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>
<p>仍以person()函数为例，我们希望检查是否有city和job参数：</p>
<pre><code>def person(name, age, **kw):
    if &apos;city&apos; in kw:
        # 有city参数
        pass
    if &apos;job&apos; in kw:
        # 有job参数
        pass
    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</code></pre><p>但是调用者仍可以传入不受限制的关键字参数：</p>
<pre><code>--&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, addr=&apos;Chaoyang&apos;, zipcode=123456)</code></pre><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<pre><code>def person(name, age, *, city, job):
    print(name, age, city, job)</code></pre><p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。</p>
<p>调用方式如下：</p>
<pre><code>--&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)
Jack 24 Beijing Engineer</code></pre><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p>
<pre><code>def person(name, age, *args, city, job):
    print(name, age, args, city, job)</code></pre><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<pre><code>--&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given</code></pre><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p>
<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<pre><code>def person(name, age, *, city=&apos;Beijing&apos;, job):
    print(name, age, city, job)</code></pre><p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p>
<pre><code>--&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)
Jack 24 Beijing Engineer</code></pre><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<em>作为特殊分隔符。如果缺少</em>，Python解释器将无法识别位置参数和命名关键字参数：</p>
<pre><code>def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass</code></pre><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>比如定义一个函数，包含上述若干种参数：</p>
<pre><code>def f1(a, b, c=0, *args, **kw):
    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)

def f2(a, b, c=0, *, d, **kw):
    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</code></pre><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<pre><code>--&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
--&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
--&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)
a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {}
--&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)
a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {&apos;x&apos;: 99}
--&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {&apos;ext&apos;: None}</code></pre><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<pre><code>--&gt; args = (1, 2, 3, 4)
--&gt; kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}
--&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}
--&gt; args = (1, 2, 3)
--&gt; kw = {&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;}
--&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {&apos;x&apos;: &apos;#&apos;}</code></pre><p>所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。</p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>取一个list或者tuple的一部分元素<br>取list：<br>    L = [‘Michael’, ‘Sarah’, ‘Tracy’, ‘Bob’, ‘Jack’]<br>    –&gt; L[0:3]<br>    [‘Michael’, ‘Sarah’, ‘Tracy’]<br>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>如果第一个索引是0，还可以省略：<br>    –&gt; L[:3]<br>    [‘Michael’, ‘Sarah’, ‘Tracy’]</p>
<p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：<br>    –&gt; L[-2:]<br>    [‘Bob’, ‘Jack’]<br>    –&gt; L[-2:-1]<br>    [‘Bob’]<br>记住倒数第一个元素的索引是-1</p>
<p>切片操作十分有用。我们先创建一个0-99的数列：<br>    –&gt; L = list(range(100))<br>    –&gt; L<br>    [0, 1, 2, 3, …, 99]<br>可以通过切片轻松取出某一段数列。比如前10个数：<br>    –&gt; L[:10]<br>    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>后10个数：<br>    –&gt; L[-10:]<br>    [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]<br>前11-20个数：<br>    –&gt; L[10:20]<br>    [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]<br>前10个数，每两个取一个：<br>    –&gt; L[:10:2]<br>    [0, 2, 4, 6, 8]<br>所有数，每5个取一个：<br>    –&gt; L[::5]<br>    [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]<br>甚至什么都不写，只写[:]就可以原样复制一个list：<br>    –&gt; L[:]<br>    [0, 1, 2, 3, …, 99]</p>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：<br>    –&gt; (0, 1, 2, 3, 4, 5)[:3]<br>    (0, 1, 2)</p>
<p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：<br>    –&gt; ‘ABCDEFG’[:3]<br>    ‘ABC’<br>    –&gt; ‘ABCDEFG’[::2]<br>    ‘ACEG</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>for循环遍历<br>遍历对象<br>    –&gt; d = {‘a’: 1, ‘b’: 2, ‘c’: 3}<br>    –&gt; for key in d:<br>    …     print(key)<br>    …<br>    a<br>    c<br>    b<br>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()</p>
<p>由于字符串也是可迭代对象，因此，也可以作用于for循环：</p>
<pre><code>--&gt; for ch in &apos;ABC&apos;:
...     print(ch)
...
A
B
C</code></pre><p>那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：<br>    –&gt; from collections import Iterable<br>    –&gt; isinstance(‘abc’, Iterable) # str是否可迭代<br>    True<br>    –&gt; isinstance([1,2,3], Iterable) # list是否可迭代<br>    True<br>    –&gt; isinstance(123, Iterable) # 整数是否可迭代<br>    False</p>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：<br>    –&gt; for i, value in enumerate([‘A’, ‘B’, ‘C’]):<br>    …     print(i, value)<br>    …<br>    0 A<br>    1 B<br>    2 C</p>
<p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：<br>    –&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:<br>    …     print(x, y)<br>    …<br>    1 1<br>    2 4<br>    3 9</p>
<h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<pre><code>--&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>
<pre><code>--&gt; L = []
--&gt; for x in range(1, 11):
...    L.append(x * x)
...
--&gt; L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<pre><code>--&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></pre><p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<pre><code>--&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]</code></pre><p>还可以使用两层循环，可以生成全排列：</p>
<pre><code>--&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]
[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</code></pre><p>三层和三层以上的循环就很少用到了。</p>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<pre><code>--&gt; import os # 导入os模块，模块的概念后面讲到
--&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录
[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</code></pre><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p>
<pre><code>--&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; }
--&gt; for k, v in d.items():
...     print(k, &apos;=&apos;, v)
...
y = B
x = A
z = C</code></pre><p>因此，列表生成式也可以使用两个变量来生成list：</p>
<pre><code>--&gt; d = {&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; }
--&gt; [k + &apos;=&apos; + v for k, v in d.items()]
[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</code></pre><p>最后把一个list中所有的字符串变成小写：</p>
<pre><code>--&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]
--&gt; [s.lower() for s in L]
[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-nodejs-download-images" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/nodejs-download-images/">Javascript从json文件获取图片地址下载图片到本地</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/03/25/nodejs-download-images/" class="article-date">
  <time datetime="2019-03-24T16:00:00.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <pre><code>var http = require(&apos;http&apos;),fs = require(&apos;fs&apos;);
var imgs = require(&apos;./face_detection.json&apos;);  //保存图片地址的json文件
imgs.forEach((el,index) =&gt; {
  var name = &apos;&apos;;
  if(el.content.indexOf(&apos;png&apos;) != -1){
    name = index+&apos;.png&apos;;
  }else{
    name = index+&apos;.jpeg&apos;;
  }
  http.get(el.content,function(req,res){
    var imgData = &apos;&apos;;
    req.setEncoding(&apos;binary&apos;);
    req.on(&apos;data&apos;,function(chunk){
      imgData += chunk;
    })
    req.on(&apos;end&apos;,function(){
      fs.writeFile(&apos;d:/code/test/node-downimg/images/&apos;+name,imgData,&apos;binary&apos;,function(err){
        if(err){console.log(&apos;保存出错！&apos;)}else{
          console.log(&apos;保存成功!&apos;)
        }
      })
    })
  })

});</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-robotframework" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/robotframework/">RobotFramework</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/03/25/robotframework/" class="article-date">
  <time datetime="2019-03-24T16:00:00.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="Run-Keyword-If语句"><a href="#Run-Keyword-If语句" class="headerlink" title="Run Keyword If语句"></a>Run Keyword If语句</h1><pre><code>${image_number}    ${label_count}    Run Keyword If  &apos;${type}&apos;==&apos;image_classification&apos;    Set Variable    420    10
                                    ...  ELSE IF    &apos;${type}&apos;==&apos;object_detection&apos;    Set Variable    20    13
                                    ...  ELSE IF    &apos;${type}&apos;==&apos;instance_segmentation&apos;    Set Variable    500    3</code></pre><p>如上，如果满足条件为两个变量赋值<br>语法为：<br>    Run Keyword If   条件   关键字1<br>    … ELSE IF   条件   关键字2<br>    … ELSE   条件   关键字3</p>
<p>关键问题：</p>
<ol>
<li>ELSE IF必须为大写！！！</li>
<li>ELSE前面的三个点必须跟上一行的Run对齐！！！</li>
</ol>
<h1 id="RobotFramework关键字"><a href="#RobotFramework关键字" class="headerlink" title="RobotFramework关键字"></a>RobotFramework关键字</h1><p><a href="http://robotframework.org/Selenium2Library/Selenium2Library-1.8.0.html" target="_blank" rel="noopener">官方文档</a><br><strong>* Keywords *</strong><br>    Add Cookie<br>    Add Location Strategy<br>    Alert Should Be Present<br>    Assign Id To Element<br>    Capture Page Screenshot<br>    Checkbox Should Be Selected<br>    Checkbox Should Not Be Selected<br>    Choose Cancel On Next Confirmation<br>    Choose File<br>    Choose Ok On Next Confirmation<br>    Clear Element Text<br>    Click Button<br>    Click Element<br>    Click Element At Coordinates<br>    Click Image<br>    Click Link<br>    Close All Browsers<br>    Close Browser<br>    Close Window<br>    Confirm Action<br>    Create Webdriver<br>    Current Frame Contains<br>    Current Frame Should Not Contain<br>    Delete All Cookies<br>    Delete Cookie<br>    Dismiss Alert<br>    Double Click Element<br>    Drag And Drop<br>    Drag And Drop By Offset<br>    Element Should Be Disabled<br>    Element Should Be Enabled<br>    Element Should Be Visible<br>    Element Should Contain<br>    Element Should Not Be Visible<br>    Element Should Not Contain<br>    Element Text Should Be<br>    Execute Async Javascript<br>    Execute Javascript<br>    Focus<br>    Frame Should Contain<br>    Get Alert Message<br>    Get All Links<br>    Get Cookie Value<br>    Get Cookies<br>    Get Element Attribute<br>    Get Element Size<br>    Get Horizontal Position<br>    Get List Items<br>    Get Location<br>    Get Matching Xpath Count<br>    Get Selected List Label<br>    Get Selected List Labels<br>    Get Selected List Value<br>    Get Selected List Values<br>    Get Selenium Implicit Wait<br>    Get Selenium Speed<br>    Get Selenium Timeout<br>    Get Source<br>    Get Table Cell<br>    Get Text<br>    Get Title<br>    Get Value<br>    Get Vertical Position<br>    Get Webelement<br>    Get Webelements<br>    Get Window Identifiers<br>    Get Window Names<br>    Get Window Position<br>    Get Window Size<br>    Get Window Titles<br>    Go Back<br>    Go To<br>    Input Password<br>    Input Text<br>    Input Text Into Prompt<br>    List Selection Should Be<br>    List Should Have No Selections<br>    List Windows<br>    Location Should Be<br>    Location Should Contain<br>    Locator Should Match X Times<br>    Log Location<br>    Log Source<br>    Log Title<br>    Maximize Browser Window<br>    Mouse Down<br>    Mouse Down On Image<br>    Mouse Down On Link<br>    Mouse Out<br>    Mouse Over<br>    Mouse Up<br>    Open Browser<br>    Open Context Menu<br>    Page Should Contain<br>    Page Should Contain Button<br>    Page Should Contain Checkbox<br>    Page Should Contain Element<br>    Page Should Contain Image<br>    Page Should Contain Link<br>    Page Should Contain List<br>    Page Should Contain Radio Button<br>    Page Should Contain Textfield<br>    Page Should Not Contain<br>    Page Should Not Contain Button<br>    Page Should Not Contain Checkbox<br>    Page Should Not Contain Element<br>    Page Should Not Contain Image<br>    Page Should Not Contain Link<br>    Page Should Not Contain List<br>    Page Should Not Contain Radio Button<br>    Page Should Not Contain Textfield<br>    Press Key<br>    Radio Button Should Be Set To<br>    Radio Button Should Not Be Selected<br>    Register Keyword To Run On Failure<br>    Reload Page<br>    Remove Location Strategy<br>    Select All From List<br>    Select Checkbox<br>    Select Frame<br>    Select From List<br>    Select From List By Index<br>    Select From List By Label<br>    Select From List By Value<br>    Select Radio Button<br>    Select Window<br>    Set Browser Implicit Wait<br>    Set Screenshot Directory<br>    Set Selenium Implicit Wait<br>    Set Selenium Speed<br>    Set Selenium Timeout<br>    Set Window Position<br>    Set Window Size<br>    Simulate<br>    Submit Form<br>    Switch Browser<br>    Table Cell Should Contain<br>    Table Column Should Contain<br>    Table Footer Should Contain<br>    Table Header Should Contain<br>    Table Row Should Contain<br>    Table Should Contain<br>    Textarea Should Contain<br>    Textarea Value Should Be<br>    Textfield Should Contain<br>    Textfield Value Should Be<br>    Title Should Be<br>    Unselect Checkbox<br>    Unselect Frame<br>    Unselect From List<br>    Unselect From List By Index<br>    Unselect From List By Label<br>    Unselect From List By Value<br>    Wait For Condition<br>    Wait Until Element Contains<br>    Wait Until Element Does Not Contain<br>    Wait Until Element Is Enabled<br>    Wait Until Element Is Not Visible<br>    Wait Until Element Is Visible<br>    Wait Until Page Contains<br>    Wait Until Page Contains Element<br>    Wait Until Page Does Not Contain<br>    Wait Until Page Does Not Contain Element<br>    Xpath Should Match X Times</p>
<h1 id="BuiltIn关键字"><a href="#BuiltIn关键字" class="headerlink" title="BuiltIn关键字"></a>BuiltIn关键字</h1><p>官方文档 <a href="http://robotframework.org/robotframework/latest/libraries/BuiltIn.html)" target="_blank" rel="noopener">http://robotframework.org/robotframework/latest/libraries/BuiltIn.html)</a></p>
<pre><code>Call Method
Catenate
Comment
Continue For Loop
Continue For Loop If
Convert To Binary
Convert To Boolean
Convert To Bytes
Convert To Hex
Convert To Integer
Convert To Number
Convert To Octal
Convert To String
Create Dictionary
Create List
Evaluate
Exit For Loop
Exit For Loop If
Fail
Fatal Error
Get Count
Get Length
Get Library Instance
Get Time
Get Variable Value
Get Variables
Import Library
Import Resource
Import Variables
Keyword Should Exist
Length Should Be
Log
Log Many
Log To Console
Log Variables
No Operation
Pass Execution
Pass Execution If
Regexp Escape
Reload Library
Remove Tags
Repeat Keyword
Replace Variables
Return From Keyword
Return From Keyword If
Run Keyword
Run Keyword And Continue On Failure
Run Keyword And Expect Error
Run Keyword And Ignore Error
Run Keyword And Return
Run Keyword And Return If
Run Keyword And Return Status
Run Keyword If
Run Keyword If All Critical Tests Passed
Run Keyword If All Tests Passed
Run Keyword If Any Critical Tests Failed
Run Keyword If Any Tests Failed
Run Keyword If Test Failed
Run Keyword If Test Passed
Run Keyword If Timeout Occurred
Run Keyword Unless
Run Keywords
Set Global Variable
Set Library Search Order
Set Log Level
Set Suite Documentation
Set Suite Metadata
Set Suite Variable
Set Tags
Set Task Variable
Set Test Documentation
Set Test Message
Set Test Variable
Set Variable
Set Variable If
Should Be Empty
Should Be Equal
Should Be Equal As Integers
Should Be Equal As Numbers
Should Be Equal As Strings
Should Be True
Should Contain
Should Contain Any
Should Contain X Times
Should End With
Should Match
Should Match Regexp
Should Not Be Empty
Should Not Be Equal
Should Not Be Equal As Integers
Should Not Be Equal As Numbers
Should Not Be Equal As Strings
Should Not Be True
Should Not Contain
Should Not Contain Any
Should Not End With
Should Not Match
Should Not Match Regexp
Should Not Start With
Should Start With
Sleep
Variable Should Exist
Variable Should Not Exist
Wait Until Keyword Succeeds</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Javascript_vanceded_techniques" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/08/Javascript_vanceded_techniques/">Javascript高级函数</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/03/08/Javascript_vanceded_techniques/" class="article-date">
  <time datetime="2019-03-07T16:00:00.000Z" itemprop="datePublished">2019-03-08</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="检测数组、函数、正则"><a href="#检测数组、函数、正则" class="headerlink" title="检测数组、函数、正则"></a>检测数组、函数、正则</h1><pre><code>function isArray(value){
  return Object.prototype.toString.call(value) == &apos;[object Array]&apos;;
}
function isArray(value){
  return Object.prototype.toString.call(value) == &apos;[object Function]&apos;;
}
function isArray(value){
  return Object.prototype.toString.call(value) == &apos;[object RegExp]&apos;;
}</code></pre><ul>
<li>检测数组的方法还有ES6的isArray()方法</li>
</ul>
<h1 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h1><pre><code>function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
}
var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</code></pre><ul>
<li><p>上面这个构造函数当和new操作符连用时会创建一个新的Person对象，但是如果没有使用new操作符，this会映射到window上，导致错误对象属性的意外增加。使用作用域安全的构造函数：</p>
<p>  function Person(name, age, job){</p>
<pre><code>if (this instanceof Person){
  this.name = name;
  this.age = age;
  this.job = job;
} else {
  return new Person(name, age, job);
}</code></pre><p>  }<br>  var person1 = Person(“Nicholas”, 29, “Software Engineer”);<br>  alert(window.name); //“”<br>  alert(person1.name); //“Nicholas”<br>  var person2 = new Person(“Shelby”, 34, “Ergonomist”);<br>  alert(person2.name); //“Shelby”</p>
</li>
<li><p>但是如果你使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏，例如：</p>
<p>  function Polygon(sides){</p>
<pre><code>if (this instanceof Polygon) {
  this.sides = sides;
  this.getArea = function(){
    return 0;
  };
} else {
  return new Polygon(sides);
}</code></pre><p>  }<br>  function Rectangle(width, height){</p>
<pre><code>Polygon.call(this, 2);
this.width = width;
this.height = height;
this.getArea = function(){
  return this.width * this.height;
};</code></pre><p>  }<br>  var rect = new Rectangle(5, 10);<br>  alert(rect.sides); //undefined</p>
</li>
<li><p>构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题：</p>
<p>  function Polygon(sides){</p>
<pre><code>if (this instanceof Polygon) {
  this.sides = sides;
  this.getArea = function(){
    return 0;
  };
} else {
  return new Polygon(sides);
}</code></pre><p>  }<br>  function Rectangle(width, height){</p>
<pre><code>Polygon.call(this, 2);
this.width = width;
this.height = height;
this.getArea = function(){
  return this.width * this.height;
};</code></pre><p>  }<br>  Rectangle.prototype = new Polygon();<br>  var rect = new Rectangle(5, 10);<br>  alert(rect.sides); //2</p>
</li>
</ul>
<h1 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h1><h1 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h1><h1 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h1><h2 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h2><p>默认情况下，所有对象都是可扩展的，任何时候都可以向对象中添加属性和方法。使用Object.preventExtensions()可以改变这个行为，不能再给对象添加属性和方法<br>    var person = { name: “Nicholas” };<br>    Object.preventExtensions(person);<br>    person.age = 29;<br>    alert(person.age); //undefined</p>
<p>在非严格模式下，添加新成员会静默失败，严格模式会抛出错误。虽然不能给对象添加新成员，但已有的成员丝毫不受影响，仍可以修改和删除已有成员。使用Object.isExtensible()方法可以确定对象是否可扩展。<br>    var person = { name: “Nicholas” };<br>    alert(Object.isExtensible(person)); //true<br>    Object.preventExtensions(person);<br>    alert(Object.isExtensible(person)); //false</p>
<h2 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h2><p>密封对象不可扩展，而且已有成员的 Configurable 特性被设置为false，这就意味着不能删除属性和方法，因为不能使用Object.defineProperty()把数据修改为访问器属性。要密封对象，可以使用Object.seal()方法<br>    var person = { name: “Nicholas” };<br>    Object.seal(person);<br>    person.age = 29;<br>    alert(person.age); //undefined<br>    delete person.name;<br>    alert(person.name); //“Nicholas”</p>
<p>使用Object.isSealed()方法可以确定对象是否被密封了，因为密封的对象不可扩展，所以用Object.isExtensible()检测密封的对象也会返回false。<br>    var person = { name: “Nicholas” };<br>    alert(Object.isExtensible(person)); //true<br>    alert(Object.isSealed(person)); //false<br>    Object.seal(person);<br>    alert(Object.isExtensible(person)); //false<br>    alert(Object.isSealed(person)); //true</p>
<h2 id="冻结的对象"><a href="#冻结的对象" class="headerlink" title="冻结的对象"></a>冻结的对象</h2><p>最严格的防篡改级别是冻结对象，冻结对象既不可扩展，又是密封的，而且对象的writable特性被设置false，如果定义set函数，访问器属性仍然是可写的。使用Object.freeze()方法来冻结对象<br>    var person = { name: “Nicholas” };<br>    Object.freeze(person);<br>    person.age = 29;<br>    alert(person.age); //undefined<br>    delete person.name;<br>    alert(person.name); //“Nicholas”<br>    person.name = “Greg”;<br>    alert(person.name); //“Nicholas”<br>与密封和不允许扩展一样，对冻结的对象执行非法操作在非严格模式下会被忽略，严格模式会抛错。Object.isFrozen()方法用于检测冻结对象。因为冻结对象既是密封的又是不可扩展的，所以Object.isExtensible()和Object.isSealed()检测冻结对象分别返回false和true。<br>对于JavaScript库的作者而言，冻结对象是很有用的，冻结对象可以防止库中的核心对象被意外修改。</p>
<h1 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h1>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-react" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/01/react/">react</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/03/01/react/" class="article-date">
  <time datetime="2019-02-28T16:00:00.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="构建react组件的三种方式："><a href="#构建react组件的三种方式：" class="headerlink" title="构建react组件的三种方式："></a>构建react组件的三种方式：</h2><ul>
<li>React.createClass</li>
<li>ES6 classes</li>
<li>无状态函数</li>
</ul>
<p>示例：创建button组件元素<br>React.createClass</p>
<pre><code>const Button = React.createClass({
  getDefaultProps(){
    return {
      color: &apos;blue&apos;,
      text: &apos;Confirm&apos;
    };
  },
  render(){
    const { color, text } = this.props;
    return (
      &lt;button className={btn btn-${color}}&gt;
        &lt;em&gt;{text}&lt;/em&gt;
      &lt;/button&gt;
    )
  }
});</code></pre><p>当调用button组件时只需要使用<buton>,就可以被解析成React.createClass(Button)方法来创建Button实例。</buton></p>
<p>ES6 classes</p>
<pre><code>import React, { Component } from &apos;react&apos;;
　
class Button extends Component {
  constructor(props) {
    super(props);
  }
　
  static defaultProps = {
    color: &apos;blue&apos;,
    text: &apos;Confirm&apos;,
  };
　
  render() {
    const { color, text } = this.props;

    return (
      &lt;button className={btn btn-${color}}&gt;
        &lt;em&gt;{text}&lt;/em&gt;
      &lt;/button&gt;
    );
  }
}</code></pre><p>无状态函数</p>
<pre><code>function Button({ color = &apos;blue&apos;, text = &apos;Confirm&apos; }) {
  return (
    &lt;button className={btn btn-${color}}&gt;
      &lt;em&gt;{text}&lt;/em&gt;
    &lt;/button&gt;
  );
}</code></pre><p>无状态组件只传入 props 和 context 两个参数；也就是说，它不存在 state ，也没有生命周期方法，组件本身即上面两种 React 组件构建方法中的 render 方法。不过，像 propTypes 和 defaultProps 还是可以通过向方法设置静态属性来实现的。<br>在适合的情况下，我们都应该且必须使用无状态组件。无状态组件不像上述两种方法在调用时会创建新实例，它创建时始终保持了一个实例，避免了不必要的检查和内存分配，做到了内部优化。</p>
<h2 id="事件处理函数中的this绑定"><a href="#事件处理函数中的this绑定" class="headerlink" title="事件处理函数中的this绑定"></a>事件处理函数中的this绑定</h2><ul>
<li><p>bind方法</p>
<p>  import React, { Component } from ‘react’;<br>  　<br>  class App extends Component {</p>
<pre><code>handleClick(e, arg) {
  console.log(e, arg);
}</code></pre><p>  　 render() {</p>
<pre><code>  // 通过bind方法实现，可以传递参数
  return &lt;button onClick={this.handleClick.bind(this, &apos;test&apos;)}&gt;Test&lt;/button&gt;;
}</code></pre><p>  }</p>
<p>使用双冒号语法<br>  import React, { Component } from ‘react’;<br>　
  class App extends Component {</p>
<pre><code>handleClick(e) {
  console.log(e);
}</code></pre><p>  　</p>
<pre><code>render() {
  return &lt;button onClick={::this.handleClick}&gt;Test&lt;/button&gt;;
}</code></pre><p>  }</p>
</li>
<li><p>构造器内声明<br>在组件的构造器内完成了 this 的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听器时去执行绑定操作：</p>
<p>  import React, { Component } from ‘react’;<br>　
  class App extends Component {</p>
<pre><code>constructor(props) {
  super(props);

  thishandleClick = this.handleClick.bind(this);
}</code></pre><p>  　</p>
<pre><code>handleClick(e) {
  console.log(e);
}

render() {
  return &lt;button onClick={this.handleClick}&gt;Test&lt;/button&gt;;
}</code></pre><p>  }</p>
</li>
<li><p>箭头函数<br>箭头函数不仅是函数的“语法糖”，它还自动绑定了定义此函数作用域的 this ，因此我们不需要再对它使用 bind 方法。比如，以下方式就能运行：</p>
<p>  import React, { Component } from ‘react’;<br>　
  class App extends Component {</p>
<pre><code>const handleClick = (e) =&gt; {
  console.log(e);
};</code></pre><p>  　</p>
<pre><code>render() {
  return &lt;button onClick={this.handleClick}&gt;Test&lt;/button&gt;;
}</code></pre><p>  }</p>
<p>或者</p>
<p>  import React, { Component } from ‘react’;<br>　
  class App extends Component {</p>
<pre><code>handleClick(e) {
  console.log(e);
}</code></pre><p>  　</p>
<pre><code>render() {
  return &lt;button onClick={() =&gt; this.handleClick()}&gt;Test&lt;/button&gt;
}</code></pre><p>  }</p>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-nodejs forever" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/14/nodejs forever/">使用forever让node.js持久运行</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/10/14/nodejs forever/" class="article-date">
  <time datetime="2018-10-13T16:00:00.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <pre><code>npm install forever -g #安装
forever start app.js #启动应用
forever stop app.js #关闭应用
forever restartall #重启所有应用</code></pre><h2 id="输出日志和错误"><a href="#输出日志和错误" class="headerlink" title="输出日志和错误"></a>输出日志和错误</h2><pre><code>forever start -l forever.log -o out.log -e err.log app.js</code></pre><p>指定forever信息输出文件，当然，默认它会放到~/.forever/forever.log<br>    forever start -l forever.log app.js</p>
<p>指定app.js中的日志信息和错误日志输出文件，<br>-o 就是console.log输出的信息，-e 就是console.error输出的信息<br>    forever start -o out.log -e err.log app.js</p>
<p>追加日志，forever默认是不能覆盖上次的启动日志，<br>所以如果第二次启动不加-a，则会不让运行<br>    forever start -l forever.log -a app.js</p>
<p>监听当前文件夹下的所有文件改动（不太建议这样）<br>    forever start -w app.js</p>
<p>显示所有运行的服务<br>    forever list</p>
<h2 id="停止操作"><a href="#停止操作" class="headerlink" title="停止操作"></a>停止操作</h2><p>停止所有运行的node App<br>    forever stopall</p>
<p>停止其中一个node App<br>    forever stop app.js</p>
<p>当然还可以这样<br>forever list 找到对应的id，然后：<br>    forever stop [id]</p>
<p>开发环境下<br>    NODE_ENV=development forever start -l forever.log -e err.log -a app.js</p>
<p>线上环境下<br>    NODE_ENV=production forever start -l ~/.forever/forever.log -e ~/.forever/err.log -w -a app.js</p>
<p>上面加上NODE_ENV为了让app.js辨认当前是什么环境用的</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-linux commd" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/linux commd/">linux 命令使用记录</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/09/28/linux commd/" class="article-date">
  <time datetime="2018-09-27T16:00:00.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>后台方式启动mongodbb服务</p>
<pre><code>mongod -f /usr/local/src/mongodb/data/cong/mongod.conf</code></pre><p>Linux中如何让命令在后台运行(切换到后台，关闭shell服务也会断开)<br>在下达的命令后面加上&amp;，就可以使该命令在后台进行工作，这样做最大的好处就是不怕被ctrl+c这个中断指令所中断。<br>那大家可能又要问了，在后台执行的程序怎么使它恢复到前台来运行呢？很简单，只用执行fg这个命令，就可以了。<br>可能有些同学又要问了，我现在已经在前台运行的命令，我能把它放到后台去运行么？当然可以了，只要执行ctrl+z就可以做到了。是不是很赞啊！<br>说到这里可能有些同学又要问了，如果我有多个进程在后台运行，那如何恢复到前台来执行呢？这时候就要用到jobs这个命令了，通过jobs这个命令，能够列出所有在后台执行的进程，那个中括号（[ ]）里面的数字就是 jobs 的代号啰 ，通过fg %number 就可以恢复指定的后台进程。<br>使用nohup让程序在远程主机后台运行。Unix/Linux下一般比如想让某个程序在后台运行，很多都是使用 &amp; 在程序结尾来让程序自动运行。但是如果终端关闭，那么程序也会被关闭。但是为了能够后台运行，那么我们就可以使用nohup这个命令，比如我们有个test.php需要在后台运行，并且希望在后台能够定期运行，那么就使用nohup：<br>    nohup /root/test.php &amp;<br>提示：<br>[~]$ appending output to nohup.out 证明运行成功，同时把程序运行的输出信息放到当前目录的 nohup.out 文件中去。<br>附：nohup命令参考 nohup 命令 用途：不挂断地运行命令。 语法：nohup Command [ Arg … ] [ &amp; ]<br>描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所<br>有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 […]<br>后台运行的两个命令 &amp; 和 ctr+z<br>一开始就+“&amp;”具体方法是： [命令]空格[&amp;]<br>比如：<br>    [root@pcmxexweb etc]# find / -name xml &amp;<br>这样，这个查找程序就会在后台运行。它运行的同时不影响你干别的事情。<br>但是有的时候忘记了在命令之后加上„&amp;‟符号，又不愿意停下此命令重新改写。这是可<br>以按[ctrl+z]，把当前程序切入后台。<br>但是要注意此时在后台的这个程序是处于 Stopped 状态（注意看上面最后一行）。<br>用jobs查看下后台运行程序。<br>用fg %[编号]切回前台</p>

      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/cat.jpg" title="图片来自网络">
    <h3 class="avatar-name">
      
        jamestoms
      
    </h3>
    <p class="avatar-slogan">
      我只是个小前端
    </p>
  </div>
</div>


  
    

  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/19/javascript/">Javascript</a>
          </li>
        
          <li>
            <a href="/2019/05/16/webpack/">webpack基本配置</a>
          </li>
        
          <li>
            <a href="/2019/05/07/Vue-component-interaction/">Vue组件交互的方式</a>
          </li>
        
          <li>
            <a href="/2019/04/09/python/">python</a>
          </li>
        
          <li>
            <a href="/2019/03/25/nodejs-download-images/">Javascript从json文件获取图片地址下载图片到本地</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://jamestoms.github.io/" title target="_blank">jamestoms</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 jamestoms &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/Jamestoms" class="mobile-nav-link">github</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>